<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <title>D√™Gusto Games ‚Äî 2 Jogos 3D (Mobile)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <style>
    /* Tema inspirado em degusto.store ‚Äî alegre e limpo */
    :root{
      --bg1: #FFDEE9;
      --bg2: #B5FFFC;
      --accent1: #FF7A59;
      --accent2: #7C4DFF;
      --card: rgba(255,255,255,0.12);
      --text: #042028;
      --happiness: #ffd166;
    }
    html,body{
      height:100%;
      margin:0;
      font-family: "Inter", "Helvetica Neue", Arial, sans-serif;
      -webkit-tap-highlight-color: transparent;
      background: linear-gradient(135deg,var(--bg1) 0%, var(--bg2) 100%);
      color:var(--text);
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }
    .wrap{
      max-width:1100px;
      margin:0 auto;
      padding:14px;
    }
    header{
      display:flex;
      align-items:center;
      gap:12px;
      justify-content:space-between;
      margin-bottom:10px;
    }
    .brand{
      display:flex;
      gap:12px;
      align-items:center;
    }
    .logo{
      width:52px;height:52px;border-radius:12px;
      background: linear-gradient(135deg,var(--accent1),var(--accent2));
      display:flex;align-items:center;justify-content:center;color:white;font-weight:800;
      box-shadow: 0 8px 20px rgba(0,0,0,0.12);
    }
    h1{font-size:18px;margin:0}
    p.sub{margin:0;font-size:12px;color:rgba(0,0,0,0.55)}
    .controls{display:flex;gap:8px;align-items:center}
    button.btn{
      border:0;padding:10px 12px;border-radius:10px;font-weight:700;
      background:linear-gradient(90deg,var(--accent1),var(--accent2));
      color:#fff;box-shadow:0 6px 18px rgba(0,0,0,0.12);cursor:pointer;
      -webkit-user-select:none; user-select:none;
    }
    button.ghost{background:transparent;color:var(--text);border:2px solid rgba(0,0,0,0.06)}
    .grid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
    }
    .card{
      background:var(--card);
      border-radius:14px;
      padding:10px;
      min-height:420px;
      box-shadow: 0 10px 30px rgba(2,12,20,0.06);
      display:flex;
      flex-direction:column;
      align-items:stretch;
      justify-content:flex-start;
      overflow:hidden;
    }
    .card h2{margin:0 0 6px;font-size:15px}
    .canvas-wrap{flex:1;display:flex;align-items:center;justify-content:center;position:relative}
    canvas{width:100%;height:100%;border-radius:10px;display:block;background:transparent}
    .hud{
      position:absolute;left:10px;top:10px;background:rgba(255,255,255,0.88);padding:6px 10px;border-radius:10px;font-weight:700;color:var(--text);
      box-shadow:0 6px 16px rgba(0,0,0,0.08);font-size:13px
    }
    .hint{font-size:12px;color:rgba(0,0,0,0.55);text-align:center;margin-top:10px}
    footer{margin-top:12px;text-align:center;font-size:12px;color:rgba(0,0,0,0.6)}
    @media(max-width:900px){
      .grid{grid-template-columns:1fr}
      .card{min-height:360px}
      h1{font-size:16px}
    }
  </style>

  <!-- three.js CDN (online) -->
  <script src="https://unpkg.com/three@0.154.0/build/three.min.js"></script>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="brand">
        <div class="logo">DG</div>
        <div>
          <h1>D√™Gusto Games</h1>
          <p class="sub">Divers√£o leve ‚Äî otimizado para celular üç≠</p>
        </div>
      </div>
      <div class="controls">
        <button class="btn" id="open-all">Abrir ambos</button>
        <button class="btn ghost" id="stop-all">Parar tudo</button>
      </div>
    </header>

    <div class="grid">
      <!-- Jogo 1: Cubo Saltitante (Tap Runner) -->
      <div class="card" id="card-runner">
        <h2>üüß Cubo Saltitante ‚Äî Toque pra pular</h2>
        <div class="canvas-wrap">
          <div class="hud" id="score-runner">Pontos: 0</div>
          <canvas id="canvas-runner" tabindex="0"></canvas>
        </div>
        <div style="display:flex;gap:8px;justify-content:center;margin-top:10px">
          <button class="btn" id="start-runner">Iniciar</button>
          <button class="btn ghost" id="restart-runner">Reiniciar</button>
        </div>
        <p class="hint">Toque na tela pra pular. Jogo infinito ‚Äî desvie de buracos e plataformas.</p>
      </div>

      <!-- Jogo 2: Bolinha Colorida (Dodge Ball) -->
      <div class="card" id="card-dodge">
        <h2>üîµ Bolinha Colorida ‚Äî Desvie dos obst√°culos</h2>
        <div class="canvas-wrap">
          <div class="hud" id="score-dodge">Pontos: 0</div>
          <canvas id="canvas-dodge" tabindex="0"></canvas>
        </div>
        <div style="display:flex;gap:8px;justify-content:center;margin-top:10px">
          <button class="btn" id="start-dodge">Iniciar</button>
          <button class="btn ghost" id="restart-dodge">Reiniciar</button>
        </div>
        <p class="hint">Arraste para mover a bolinha. Obst√°culos v√™m em sua dire√ß√£o ‚Äî segure para mover r√°pido.</p>
      </div>
    </div>

    <footer>Cr√©ditos: D√™Gusto ‚Ä¢ Design feliz üç∞</footer>
  </div>

<script>
/* ========== UTILIDADES GERAIS ========== */
function resizeRenderer(renderer) {
  const canvas = renderer.domElement;
  const width = canvas.clientWidth;
  const height = canvas.clientHeight;
  const DPR = window.devicePixelRatio || 1;
  if (canvas.width !== Math.floor(width * DPR) || canvas.height !== Math.floor(height * DPR)) {
    renderer.setSize(Math.floor(width * DPR), Math.floor(height * DPR), false);
    return true;
  }
  return false;
}
function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

/* ======= JOGO 1: CUBO SALTITANTE (TOUCH RUNNER) ======= */
(function(){
  const canvas = document.getElementById('canvas-runner');
  const scoreEl = document.getElementById('score-runner');
  let renderer, scene, camera, animId;
  let cube, groundGroup;
  let velocityY = 0, gravity = -18;
  let onGround = true;
  let spawnZ = -4;
  let speed = 5;
  let distance = 0, score = 0;
  let running = false;
  let lastTime = 0;

  function init() {
    // Renderer
    renderer = new THREE.WebGLRenderer({canvas, antialias:true, alpha:true});
    renderer.setPixelRatio(window.devicePixelRatio || 1);
    renderer.setClearColor(0x000000, 0); // transparent
    scene = new THREE.Scene();

    // Camera
    camera = new THREE.PerspectiveCamera(55, 1, 0.1, 100);
    camera.position.set(0,2.2,6);
    camera.lookAt(0,1,0);

    // Light
    const amb = new THREE.HemisphereLight(0xffffff, 0x444455, 0.9);
    const dir = new THREE.DirectionalLight(0xffffff, 0.6);
    dir.position.set(4,10,4);
    scene.add(amb, dir);

    // Ground group (platforms)
    groundGroup = new THREE.Group();
    scene.add(groundGroup);

    const baseMat = new THREE.MeshStandardMaterial({color:0xffffff, roughness:0.7, metalness:0.05});
    // Starter platforms
    for(let i=0;i<10;i++) spawnPlatform(i * -2, (i%7===0) ? -1 : 0);

    // Player cube
    const geom = new THREE.BoxGeometry(0.9,0.9,0.9);
    const mat = new THREE.MeshStandardMaterial({color:0xff7a59, roughness:0.4});
    cube = new THREE.Mesh(geom, mat);
    cube.position.set(0,0.5,0.5);
    scene.add(cube);

    // Simple background cheerful sphere
    const back = new THREE.Mesh(new THREE.SphereGeometry(18, 12, 12), new THREE.MeshBasicMaterial({color:0xfff0d6, opacity:0.06, transparent:true}));
    back.position.set(0,6,-10);
    scene.add(back);

    // touch to jump
    function jump(){
      if(!running) return;
      if(onGround){
        velocityY = 7.5;
        onGround = false;
      } else if (velocityY > 0.5) {
        // small double-jump
        velocityY = 9;
      }
    }
    // mobile touch & click
    canvas.addEventListener('touchstart', (e)=>{ e.preventDefault(); jump(); }, {passive:false});
    canvas.addEventListener('mousedown', ()=> jump());

    window.addEventListener('resize', ()=> resizeRenderer(renderer));
  }

  function spawnPlatform(z, y = 0) {
    // platform is a flat box with a small gap sometimes
    const platformWidth = 3;
    const geom = new THREE.BoxGeometry(platformWidth, 0.35, 1.6);
    const material = new THREE.MeshStandardMaterial({color: 0xffffff, roughness:0.85});
    const mesh = new THREE.Mesh(geom, material);
    mesh.position.set( (Math.random()-0.5)*1.6, y - 0.15, z );
    groundGroup.add(mesh);
    return mesh;
  }

  function cleanupPastPlatforms() {
    // remove platforms behind camera
    for(let i=groundGroup.children.length-1;i>=0;i--){
      const g = groundGroup.children[i];
      if(g.position.z > camera.position.z + 6) {
        groundGroup.remove(g);
        g.geometry.dispose();
        if(g.material) g.material.dispose();
      }
    }
  }

  function step(time) {
    if(!running) return;
    const dt = lastTime ? Math.min((time-lastTime)/1000, 0.04) : 0.016;
    lastTime = time;

    // move platforms forward (simulate player moving)
    const moveZ = speed * dt;
    groundGroup.children.forEach(p => { p.position.z += moveZ; });

    // spawn more platforms ahead
    spawnZ -= moveZ;
    if(spawnZ < -1) {
      spawnPlatform(Math.floor(Math.random()*2)*-1 + spawnZ - 6, (Math.random()>0.85)? -1 : 0);
      spawnZ = 0;
    }

    // gravity physics for cube
    velocityY += gravity * dt;
    cube.position.y += velocityY * dt;
    if(cube.position.y <= 0.5) {
      cube.position.y = 0.5;
      velocityY = 0;
      onGround = true;
    }

    // collision: check if cube is over a platform; if not and below a threshold -> fall (end)
    let standing = false;
    for(const p of groundGroup.children) {
      const dx = Math.abs(cube.position.x - p.position.x);
      const dz = Math.abs(cube.position.z - p.position.z);
      if(dx < 1.6 && dz < 0.9 && cube.position.y - 0.5 <= (p.position.y + 0.2)) {
        standing = true;
        break;
      }
    }
    if(!standing && cube.position.y <= 0.5 && !onGround) {
      // fell into gap -> stop the game
      running = false;
      cancelAnimationFrame(animId);
      scoreEl.textContent = "Game Over ‚Äî Pontos: " + Math.floor(score);
      return;
    }

    // update score by distance/time
    distance += speed * dt;
    score = distance * 10;
    scoreEl.textContent = "Pontos: " + Math.floor(score);

    cleanupPastPlatforms();

    // slight cube rotation for visual fun
    cube.rotation.x += 0.01;
    cube.rotation.y += 0.02;

    if(resizeRenderer(renderer)){
      camera.aspect = renderer.domElement.clientWidth / Math.max(1, renderer.domElement.clientHeight);
      camera.updateProjectionMatrix();
    }
    renderer.render(scene, camera);
    animId = requestAnimationFrame(step);
  }

  // controls
  document.getElementById('start-runner').addEventListener('click', ()=>{
    if(!renderer) init();
    if(!running){
      running = true;
      lastTime = 0;
      distance = 0; score=0;
      animId = requestAnimationFrame(step);
    }
  });
  document.getElementById('restart-runner').addEventListener('click', ()=>{
    // stop and re-init
    running = false;
    if(animId) cancelAnimationFrame(animId);
    if(renderer){
      renderer.dispose(); renderer = null;
    }
    // clear DOM canvas pixels
    const ctx = canvas.getContext('2d'); ctx.clearRect(0,0,canvas.width,canvas.height);
    // re-init and start
    init();
    running = true;
    lastTime = 0;
    distance = 0; score=0;
    animId = requestAnimationFrame(step);
  });

  // auto init visuals (but not start)
  init();

  // stop function for global stop
  window._stopRunner = function(){
    running = false;
    if(animId) cancelAnimationFrame(animId);
    if(renderer){ renderer.dispose(); renderer = null; }
    const ctx = canvas.getContext('2d'); ctx.clearRect(0,0,canvas.width,canvas.height);
  };
})();

/* ======= JOGO 2: BOLINHA COLORIDA (DODGE) ======= */
(function(){
  const canvas = document.getElementById('canvas-dodge');
  const scoreEl = document.getElementById('score-dodge');
  let renderer, scene, camera, animId;
  let ball, obstacles = [];
  let running = false;
  let lastTime = 0, score = 0;
  let ballX = 0;
  const laneWidth = 3.6;
  let canvasTouch = {active:false, x:0};

  function init(){
    renderer = new THREE.WebGLRenderer({canvas, antialias:true, alpha:true});
    renderer.setPixelRatio(window.devicePixelRatio || 1);
    renderer.setClearColor(0x000000, 0); // transparent
    scene = new THREE.Scene();

    camera = new THREE.PerspectiveCamera(60, 1, 0.1, 100);
    camera.position.set(0,3.2,6);
    camera.lookAt(0,1,0);

    // lights
    scene.add(new THREE.HemisphereLight(0xffffff, 0x444455, 0.95));
    const dl = new THREE.DirectionalLight(0xffffff, 0.5);
    dl.position.set(5,10,5); scene.add(dl);

    // floor plane visual
    const floor = new THREE.Mesh(new THREE.PlaneGeometry(12,30), new THREE.MeshStandardMaterial({color:0xffffff, roughness:0.95}));
    floor.rotation.x = -Math.PI/2; floor.position.y = 0;
    floor.material.opacity = 0.95; floor.material.transparent = true;
    scene.add(floor);

    // player ball
    const geom = new THREE.SphereGeometry(0.55, 12, 12);
    const mat = new THREE.MeshStandardMaterial({color:0x4da6ff, roughness:0.4});
    ball = new THREE.Mesh(geom, mat);
    ball.position.set(0,0.6,2);
    scene.add(ball);

    // gentle background
    const back = new THREE.Mesh(new THREE.SphereGeometry(14, 12,12), new THREE.MeshBasicMaterial({color:0xfff1d6, opacity:0.05, transparent:true}));
    back.position.set(0,6,-8); scene.add(back);

    // touch and drag for mobile
    function onStart(e){
      canvasTouch.active = true;
      canvasTouch.x = (e.touches ? e.touches[0].clientX : e.clientX);
    }
    function onMove(e){
      if(!canvasTouch.active) return;
      const x = (e.touches ? e.touches[0].clientX : e.clientX);
      const dx = x - canvasTouch.x;
      canvasTouch.x = x;
      // scale move based on canvas width
      const rect = canvas.getBoundingClientRect();
      const norm = dx / rect.width;
      ballX += norm * laneWidth * 2.0; // sensitivity
      ballX = clamp(ballX, -laneWidth/2, laneWidth/2);
    }
    function onEnd(){ canvasTouch.active = false; }

    canvas.addEventListener('touchstart', onStart, {passive:true});
    canvas.addEventListener('touchmove', onMove, {passive:true});
    canvas.addEventListener('touchend', onEnd);
    canvas.addEventListener('mousedown', onStart);
    window.addEventListener('mousemove', onMove);
    window.addEventListener('mouseup', onEnd);

    // try using device orientation for tilt control (optional)
    if(window.DeviceOrientationEvent){
      window.addEventListener('deviceorientation', (ev)=>{
        if(Math.abs(ev.gamma) > 2){ // left-right tilt
          // gamma range approx -90..90
          const g = clamp(ev.gamma, -30, 30) / 30; // -1..1
          ballX = g * (laneWidth/2);
        }
      });
    }

    // spawn initial obstacles
    for(let i=0;i<6;i++) spawnObstacle( - (i*6 + 6) );
    window.addEventListener('resize', ()=> resizeRenderer(renderer));
  }

  function spawnObstacle(zPos) {
    const geom = new THREE.BoxGeometry(1.1,1.1,1.1);
    const color = new THREE.Color().setHSL(Math.random()*0.6, 0.7, 0.5);
    const mat = new THREE.MeshStandardMaterial({color});
    const obs = new THREE.Mesh(geom, mat);
    obs.position.set( (Math.random()-0.5) * laneWidth, 0.55, zPos );
    scene.add(obs);
    obstacles.push(obs);
  }

  function step(time){
    if(!running) return;
    const dt = lastTime ? Math.min((time-lastTime)/1000, 0.04) : 0.016;
    lastTime = time;

    // move obstacles toward camera
    const speed = 6;
    for(let i=obstacles.length-1;i>=0;i--){
      const o = obstacles[i];
      o.position.z += speed * dt;
      if(o.position.z > 8){
        // recycle
        o.position.z = -40 - Math.random()*20;
        o.position.x = (Math.random()-0.5) * laneWidth;
        score += 1;
      }
      // check collision with ball (distance check)
      const dx = o.position.x - ball.position.x;
      const dz = o.position.z - ball.position.z;
      const dist2 = dx*dx + dz*dz;
      if(dist2 < (0.9*0.9)) {
        // collision -> game over
        running = false;
        cancelAnimationFrame(animId);
        scoreEl.textContent = "Game Over ‚Äî Pontos: " + Math.floor(score);
        return;
      }
    }

    // apply ballX smoothing and update
    ball.position.x += (ballX - ball.position.x) * Math.min(0.25, dt * 10);

    scoreEl.textContent = "Pontos: " + Math.floor(score);

    if(resizeRenderer(renderer)){
      camera.aspect = renderer.domElement.clientWidth / Math.max(1, renderer.domElement.clientHeight);
      camera.updateProjectionMatrix();
    }
    renderer.render(scene, camera);
    animId = requestAnimationFrame(step);
  }

  document.getElementById('start-dodge').addEventListener('click', ()=>{
    if(!renderer) init();
    if(!running){
      running = true;
      lastTime = 0;
      score = 0;
      animId = requestAnimationFrame(step);
    }
  });
  document.getElementById('restart-dodge').addEventListener('click', ()=>{
    running = false;
    if(animId) cancelAnimationFrame(animId);
    if(renderer){ renderer.dispose(); renderer = null; }
    const ctx = canvas.getContext('2d'); ctx.clearRect(0,0,canvas.width,canvas.height);
    // reset variables
    obstacles.forEach(o=>{ if(o.geometry) o.geometry.dispose(); if(o.material) o.material.dispose(); if(o.parent) o.parent.remove(o); });
    obstacles = [];
    ballX = 0; score = 0;
    init();
    running = true;
    lastTime = 0;
    animId = requestAnimationFrame(step);
  });

  init();

  window._stopDodge = function(){
    running = false;
    if(animId) cancelAnimationFrame(animId);
    if(renderer){ renderer.dispose(); renderer = null; }
    const ctx = canvas.getContext('2d'); ctx.clearRect(0,0,canvas.width,canvas.height);
  };
})();

/* ===== GLOBAL CONTROLS ===== */
document.getElementById('open-all').addEventListener('click', ()=>{
  // start both games
  document.getElementById('start-runner').click();
  document.getElementById('start-dodge').click();
});
document.getElementById('stop-all').addEventListener('click', ()=>{
  if(window._stopRunner) window._stopRunner();
  if(window._stopDodge) window._stopDodge();
});

/* Prevent accidental scroll on touch move inside canvases */
['canvas-runner','canvas-dodge'].forEach(id=>{
  const c = document.getElementById(id);
  c.addEventListener('touchmove', function(e){ e.preventDefault(); }, {passive:false});
});
</script>
</body>
</html>
